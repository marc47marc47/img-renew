# 開發文件 (DEVELOP.md)

本文檔旨在說明 `img-renew` 專案的開發細節，包括資料結構、相依的函式庫及程式執行流程。

## 1. 資料結構

由於本專案專注於圖片處理，核心資料結構將圍繞圖片的表示。

```rust
/// 代表一張圖片
struct Image {
    /// 圖片寬度
    width: u32,
    /// 圖片高度
    height: u32,
    /// 像素資料，以 RGBA 格式儲存
    pixels: Vec<u8>,
}
```

我們主要會使用 `image` crate 提供的 `DynamicImage` 和 `ImageBuffer` 等結構來進行圖片的讀取、操作和儲存。

## 2. 開發所需的 Rust Libs

為了實現圖片的放大和清晰化，我們需要引入以下 Rust 函式庫。請將它們新增至 `Cargo.toml`：

```toml
[dependencies]
image = "0.25.1"  # 核心圖片處理庫，用於讀取、寫入、縮放等
imageproc = "0.25.0" # 提供進階圖片處理功能，如濾鏡和卷積
```

- **`image`**: 提供圖片的編碼、解碼以及多種圖片操作功能，是本專案的基礎。
- **`imageproc`**: 建立在 `image` 之上，提供繪圖、卷積濾鏡（可用於清晰化）等功能。

## 3. 程式執行流程

### 方法一：傳統圖片處理

此方法使用 `image` 和 `imageproc` crate 提供的標準函式庫進行處理。

1.  **讀取輸入圖片**: 使用 `image::open()` 讀取圖片。
2.  **圖片放大 (Enlarge)**: 使用 `DynamicImage::resize()` 搭配高品質的插值濾鏡（如 `Lanczos3`）。
3.  **圖片清晰化 (Sharpen)**: 使用自訂卷積核心（Kernel）對每個像素進行計算。
4.  **儲存結果圖片**: 使用 `DynamicImage::save()` 儲存。

---

### 方法二：使用 AI 模型進行增強 (Advanced)

此方法利用預訓練的深度學習模型來實現更高品質的圖片放大和細節修復（超解析度）。我們將使用 `tract-onnx` crate 在 Rust 中運行 ONNX 格式的模型。

#### A. AI 開發所需的 Libs

請將以下函式庫新增至 `Cargo.toml`：

```toml
[dependencies]
image = "0.25.1"
# tract-onnx 用於載入並執行 ONNX AI 模型
tract-onnx = { version = "0.21.0", features = ["onnx"] }
# ndarray 用於高效的陣列運算，是 AI 模型輸入/輸出的標準格式
ndarray = "0.15.6"
```

- **`tract-onnx`**: 一個純 Rust 的深度學習推論引擎，讓我們可以載入 `.onnx` 檔案並執行模型。
- **`ndarray`**: 提供多維陣列結構 (Tensor)，這是與 AI 模型互動所必需的。

#### B. AI 程式執行流程

1.  **取得預訓練模型**:
    -   你需要一個預訓練的 AI 模型，用於圖片超解析度 (Super-Resolution)。這些模型通常以 `.onnx` 格式提供。
    -   你可以從 [ONNX Model Zoo](https://github.com/onnx/models/tree/main/validated/vision/super_resolution) 或其他模型分享平台（如 Hugging Face）下載。
    -   將下載的 `.onnx` 模型檔案放置在專案根目錄。
    -   Real-ESRGAN-x4plus_float.onnx.zip(https://huggingface.co/qualcomm/Real-ESRGAN-x4plus/resolve/main/Real-ESRGAN-x4plus_float.onnx.zip)0
2.  **圖片預處理 (Preprocessing)**:
    -   使用 `image::open()` 讀取圖片。
    -   將圖片的像素資料轉換為 `ndarray::Array` 格式的張量 (Tensor)。
    -   模型的輸入格式通常是 `[Batch, Channels, Height, Width]`，並且像素值需要正規化 (例如，縮放到 `[0, 1]` 範圍)。

3.  **載入模型並執行推論 (Inference)**:
    -   使用 `tract_onnx::onnx()` 載入 `.onnx` 模型。
    -   指定模型的輸入和輸出節點。
    -   將預處理後的張量作為輸入，執行 `model.run()`。

4.  **結果後處理 (Postprocessing)**:
    -   模型的輸出是一個包含增強後圖片資料的張量。
    -   需要將此張量轉換回 `image::ImageBuffer` 格式。
    -   這通常涉及將像素值反正規化（例如，從 `[0, 1]` 轉換回 `[0, 255]`）並重新排列維度。

5.  **儲存結果圖片**:
    -   使用 `image::ImageBuffer::save()` 將最終圖片儲存到檔案。

---

## 4. 卷積核心 (Convolution Kernel) 原理詳解

在我們的傳統圖片處理方法中，`kernel` 變數是實現清晰化效果的核心。本章節將詳細說明其原理和調整方法。

### A. `kernel` 是什麼？—— 一個「效果濾鏡」

`kernel`（中文常稱作**卷積核心**或**濾鏡**）是一個小型的數字矩陣（在我們的例子中是 3x3）。您可以把它想像成一個定義「如何改造像素」的規則藍圖。

這個改造過程被稱為「卷積 (Convolution)」。程式會拿著這個 `kernel`，像一個滑動的放大鏡，掃過原始圖片的每一個像素。在每個位置，它都會根據 `kernel` 的規則，計算出一個新的像素顏色，並將其繪製到目標圖片上。

### B. `kernel` 如何運作？—— 加權平均

對於圖片中的任意一個像素，`kernel` 的運作方式如下：

1.  將 `kernel` 的中心對準該像素。
2.  `kernel` 中的每一個數字，都與其覆蓋到的下方像素顏色值相乘。
3.  將所有 9 個相乘後的結果全部加起來。
4.  這個最終的總和，就是新圖片上該位置像素的顏色。

對於彩色圖片，這個過程會分別對紅 (R)、綠 (G)、藍 (B) 三個顏色通道獨立進行。

### C. 解析我們使用的清晰化 `kernel`

```rust
let kernel = [
    [-1.5, -1.5, -1.5],
    [-1.5, 13.0, -1.5], // 中心點
    [-1.5, -1.5, -1.5],
];
```

- **中心值 (`13.0`)**：這是目標像素自身的權重。這個數字越大，意味著原始像素的顏色在最終結果中的佔比越高。
- **周圍值 (`-1.5`)**：這是周圍 8 個鄰居像素的權重。**負數**是實現清晰化的關鍵，它代表我們要從中心像素的顏色中「減去」一部分周圍像素的顏色。

**清晰化的魔法**：當一個像素與周圍像素顏色差異很大時（即處於「邊緣」上），這個「減法」操作會極大地強化這種差異，讓邊緣看起來更銳利、更「凸顯」。如果一片區域顏色很平坦（像素與周圍鄰居顏色相近），這個操作對顏色的影響就很小。

### D. 如何調整 `kernel`？—— 規則與關係

#### 黃金規則：保持亮度不變

**`kernel` 中所有數字的總和應該等於 `1`。**

這是避免圖片變亮（過曝）或變暗的關鍵。

-   **總和 > 1**：圖片會變亮。
-   **總和 < 1**：圖片會變暗。
-   **總和 = 0**：常用於邊緣偵測，會讓大部分區域變黑。

在我們的例子中：`13.0 + 8 * (-1.5) = 13.0 - 12.0 = 1`。這就是為什麼圖片亮度能夠保持正常。

#### 調整清晰化強度

清晰化的強度由「**中心值**」和「**周圍負值**」之間的差距決定。差距越大，效果越強。

- **想增強清晰度**：
  1.  **提高**中心值（例如，從 `13.0` 提高到 `17.0`）。
  2.  為了維持總和為 `1`，**降低**（使其更負）周圍的值。
  3.  *計算*：新的周圍值 = `(1 - 新的中心值) / 8`。例如 `(1 - 17.0) / 8 = -2.0`。
  4.  *新 kernel (更強)*：
      ```rust
      [
          [-2.0, -2.0, -2.0],
          [-2.0, 17.0, -2.0],
          [-2.0, -2.0, -2.0],
      ]
      ```

- **想減弱清晰度**：
  1.  **降低**中心值（例如，從 `13.0` 降到 `9.0`）。
  2.  **提高**（使其更接近 0）周圍的值。
  3.  *計算*：`(1 - 9.0) / 8 = -1.0`。
  4.  *新 kernel (較弱)*：
      ```rust
      [
          [-1.0, -1.0, -1.0],
          [-1.0,  9.0, -1.0],
          [-1.0, -1.0, -1.0],
      ]
      ```

您可以根據這個關係，自由地在 `src/main.rs` 中修改 `kernel` 的數值，以達到您最滿意的清晰化效果。